def __new___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __new___HexBytes_obj.__call__(__mypyc_self__, cls, val):
    __mypyc_self__ :: faster_hexbytes.main.__new___HexBytes_obj
    cls :: object
    val :: union[bool, object, bytes, int, str]
    r0 :: bytes
    r1 :: object
    r2 :: str
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: faster_hexbytes.main.HexBytes
L0:
    r0 = to_bytes(val)
    if is_error(r0) goto L4 (error at __new__:42) else goto L1
L1:
    r1 = load_address PyBytes_Type
    r2 = '__new__'
    r3 = [r1, cls, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775811, 0)
    if is_error(r5) goto L5 (error at __new__:43) else goto L2
L2:
    dec_ref r0
    r6 = cast(faster_hexbytes.main.HexBytes, r5)
    if is_error(r6) goto L4 (error at __new__:43) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: faster_hexbytes.main.HexBytes
    return r7
L5:
    dec_ref r0
    goto L4

def __getitem___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __getitem___HexBytes_obj.__call__(__mypyc_self__, self, key):
    __mypyc_self__ :: faster_hexbytes.main.__getitem___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    key, r0 :: object
    r1 :: str
    r2, r3 :: object
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: union[int, bytes]
    r13 :: str
    r14 :: bool
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: faster_hexbytes.main.HexBytes
    r20 :: int
    r21 :: object
    r22 :: union[int, bytes, faster_hexbytes.main.HexBytes]
L0:
    r0 = builtins :: module
    r1 = 'super'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L11 (error at __getitem__:56) else goto L1
L1:
    r3 = faster_hexbytes.main.HexBytes :: type
    r4 = [r3, self]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 2, 0)
    dec_ref r2
    if is_error(r6) goto L11 (error at __getitem__:56) else goto L2
L2:
    r7 = '__getitem__'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L11 (error at __getitem__:56) else goto L3
L3:
    r9 = [key]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r8, r10, 1, 0)
    dec_ref r8
    if is_error(r11) goto L11 (error at __getitem__:56) else goto L4
L4:
    r12 = cast(union[int, bytes], r11)
    if is_error(r12) goto L11 (error at __getitem__:56) else goto L5
L5:
    r13 = 'hex'
    r14 = PyObject_HasAttr(r12, r13)
    if r14 goto L6 else goto L9 :: bool
L6:
    r15 = CPy_TYPE(self)
    r16 = [r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L12 (error at __getitem__:58) else goto L7
L7:
    dec_ref r12
    r19 = cast(faster_hexbytes.main.HexBytes, r18)
    if is_error(r19) goto L11 (error at __getitem__:58) else goto L8
L8:
    return r19
L9:
    r20 = unbox(int, r12)
    dec_ref r12
    if is_error(r20) goto L11 (error at __getitem__:60) else goto L10
L10:
    r21 = box(int, r20)
    return r21
L11:
    r22 = <error> :: union[int, bytes, faster_hexbytes.main.HexBytes]
    return r22
L12:
    dec_ref r12
    goto L11

def __repr___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __repr___HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.__repr___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0, r1, r2, r3, r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8, r9, r10, r11 :: str
    r12 :: object[3]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: str
    r17 :: list
    r18, r19, r20, r21 :: ptr
    r22, r23 :: str
L0:
    r0 = ''
    r1 = 'HexBytes('
    r2 = '{!r:{}}'
    r3 = '0x'
    r4 = 'hex'
    r5 = [self]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L8 (error at __repr__:63) else goto L1
L1:
    r8 = cast(str, r7)
    if is_error(r8) goto L8 (error at __repr__:63) else goto L2
L2:
    r9 = PyUnicode_Concat(r3, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at __repr__:63) else goto L3
L3:
    r10 = ''
    r11 = 'format'
    r12 = [r2, r9, r10]
    r13 = load_address r12
    r14 = PyObject_VectorcallMethod(r11, r13, 9223372036854775811, 0)
    if is_error(r14) goto L9 (error at __repr__:63) else goto L4
L4:
    dec_ref r9
    r15 = cast(str, r14)
    if is_error(r15) goto L8 (error at __repr__:63) else goto L5
L5:
    r16 = ')'
    r17 = PyList_New(3)
    if is_error(r17) goto L10 (error at __repr__:63) else goto L6
L6:
    r18 = get_element_ptr r17 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r1
    set_mem r19, r1 :: builtins.object*
    r20 = r19 + 8
    set_mem r20, r15 :: builtins.object*
    inc_ref r16
    r21 = r19 + 16
    set_mem r21, r16 :: builtins.object*
    r22 = PyUnicode_Join(r0, r17)
    dec_ref r17
    if is_error(r22) goto L8 (error at __repr__:63) else goto L7
L7:
    return r22
L8:
    r23 = <error> :: str
    return r23
L9:
    dec_ref r9
    goto L8
L10:
    dec_ref r15
    goto L8

def to_0x_hex_HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def to_0x_hex_HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.to_0x_hex_HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0, r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: str
L0:
    r0 = '0x'
    r1 = 'hex'
    r2 = [self]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L4 (error at to_0x_hex:69) else goto L1
L1:
    r5 = cast(str, r4)
    if is_error(r5) goto L4 (error at to_0x_hex:69) else goto L2
L2:
    r6 = PyUnicode_Concat(r0, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at to_0x_hex:69) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: str
    return r7

def __reduce___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __reduce___HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.__reduce___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0 :: object
    r1 :: str
    r2, r3, r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bytes
    r9 :: tuple[object, bytes]
    r10, r11 :: tuple[object, tuple[object, bytes]]
L0:
    r0 = load_address PyBytes_Type
    r1 = '__new__'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L4 (error at __reduce__:79) else goto L1
L1:
    r3 = CPy_TYPE(self)
    r4 = load_address PyBytes_Type
    r5 = [self]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    if is_error(r7) goto L5 (error at __reduce__:79) else goto L2
L2:
    r8 = cast(bytes, r7)
    if is_error(r8) goto L5 (error at __reduce__:79) else goto L3
L3:
    r9 = (r3, r8)
    r10 = (r2, r9)
    return r10
L4:
    r11 = <error> :: tuple[object, tuple[object, bytes]]
    return r11
L5:
    dec_ref r2
    dec_ref r3
    goto L4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21 :: dict
    r22 :: str
    r23, r24, r25 :: object
    r26 :: str
    r27, r28, r29, r30, r31 :: object
    r32 :: str
    r33 :: object
    r34 :: tuple[object, object, object, object, object, object]
    r35, r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: i32
    r40 :: bit
    r41 :: object
    r42 :: str
    r43 :: object
    r44 :: tuple
    r45, r46 :: object
    r47 :: str
    r48 :: bool
    r49, r50 :: str
    r51 :: object
    r52 :: object[2]
    r53 :: object_ptr
    r54 :: object
    r55, r56, r57, r58 :: dict
    r59 :: faster_hexbytes.main.__new___HexBytes_obj
    r60 :: object
    r61 :: str
    r62 :: object
    r63 :: object[1]
    r64 :: object_ptr
    r65 :: object
    r66 :: str
    r67 :: i32
    r68 :: bit
    r69 :: faster_hexbytes.main.__getitem___HexBytes_obj
    r70 :: str
    r71 :: i32
    r72 :: bit
    r73 :: faster_hexbytes.main.__repr___HexBytes_obj
    r74 :: str
    r75 :: i32
    r76 :: bit
    r77 :: faster_hexbytes.main.to_0x_hex_HexBytes_obj
    r78 :: str
    r79 :: i32
    r80 :: bit
    r81 :: faster_hexbytes.main.__reduce___HexBytes_obj
    r82 :: str
    r83 :: i32
    r84 :: bit
    r85, r86 :: str
    r87 :: i32
    r88 :: bit
    r89, r90 :: str
    r91 :: i32
    r92 :: bit
    r93, r94 :: str
    r95 :: i32
    r96 :: bit
    r97 :: object[3]
    r98 :: object_ptr
    r99 :: object
    r100 :: dict
    r101 :: str
    r102, r103 :: object
    r104 :: object[1]
    r105 :: object_ptr
    r106, r107 :: object
    r108 :: object[1]
    r109 :: object_ptr
    r110 :: object
    r111 :: dict
    r112 :: str
    r113 :: i32
    r114 :: bit
    r115 :: object
    r116 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L45 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Callable', 'Tuple', 'Type', 'Union', 'overload')
    r6 = 'typing'
    r7 = faster_hexbytes.main.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L45 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('mypyc_attr',)
    r10 = 'mypy_extensions'
    r11 = faster_hexbytes.main.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L45 (error at <module>:10) else goto L5
L5:
    mypy_extensions = r12 :: module
    dec_ref r12
    r13 = ('Self',)
    r14 = 'typing_extensions'
    r15 = faster_hexbytes.main.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L45 (error at <module>:13) else goto L6
L6:
    typing_extensions = r16 :: module
    dec_ref r16
    r17 = ('to_bytes',)
    r18 = 'faster_hexbytes._utils'
    r19 = faster_hexbytes.main.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L45 (error at <module>:17) else goto L7
L7:
    faster_hexbytes._utils = r20 :: module
    dec_ref r20
    if 0 goto L8 else goto L8 :: bool
L8:
    r21 = faster_hexbytes.main.globals :: static
    r22 = 'Union'
    r23 = CPyDict_GetItem(r21, r22)
    if is_error(r23) goto L45 (error at <module>:26) else goto L9
L9:
    r24 = load_address PyBool_Type
    r25 = builtins :: module
    r26 = 'bytearray'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L46 (error at <module>:26) else goto L10
L10:
    r28 = load_address PyBytes_Type
    r29 = load_address PyLong_Type
    r30 = load_address PyUnicode_Type
    r31 = builtins :: module
    r32 = 'memoryview'
    r33 = CPyObject_GetAttr(r31, r32)
    if is_error(r33) goto L47 (error at <module>:26) else goto L11
L11:
    inc_ref r24
    inc_ref r28
    inc_ref r29
    inc_ref r30
    r34 = (r24, r27, r28, r29, r30, r33)
    r35 = box(tuple[object, object, object, object, object, object], r34)
    r36 = PyObject_GetItem(r23, r35)
    dec_ref r23
    dec_ref r35
    if is_error(r36) goto L45 (error at <module>:26) else goto L12
L12:
    r37 = faster_hexbytes.main.globals :: static
    r38 = 'BytesLike'
    r39 = CPyDict_SetItem(r37, r38, r36)
    dec_ref r36
    r40 = r39 >= 0 :: signed
    if not r40 goto L45 (error at <module>:26) else goto L13 :: bool
L13:
    r41 = builtins :: module
    r42 = 'bytes'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L45 (error at <module>:30) else goto L14
L14:
    r44 = PyTuple_Pack(1, r43)
    dec_ref r43
    if is_error(r44) goto L45 (error at <module>:30) else goto L15
L15:
    r45 = load_address PyType_Type
    r46 = CPy_CalculateMetaclass(r45, r44)
    if is_error(r46) goto L48 (error at <module>:30) else goto L16
L16:
    r47 = '__prepare__'
    r48 = PyObject_HasAttr(r46, r47)
    if r48 goto L17 else goto L21 :: bool
L17:
    r49 = 'HexBytes'
    r50 = '__prepare__'
    r51 = CPyObject_GetAttr(r46, r50)
    if is_error(r51) goto L48 (error at <module>:30) else goto L18
L18:
    r52 = [r49, r44]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r51, r53, 2, 0)
    dec_ref r51
    if is_error(r54) goto L48 (error at <module>:30) else goto L19
L19:
    r55 = cast(dict, r54)
    if is_error(r55) goto L48 (error at <module>:30) else goto L20
L20:
    r56 = r55
    goto L23
L21:
    r57 = PyDict_New()
    if is_error(r57) goto L48 (error at <module>:30) else goto L22
L22:
    r56 = r57
L23:
    r58 = PyDict_New()
    if is_error(r58) goto L49 (error at <module>:30) else goto L24
L24:
    r59 = __new___HexBytes_obj()
    if is_error(r59) goto L50 (error at <module>:41) else goto L25
L25:
    r60 = builtins :: module
    r61 = 'staticmethod'
    r62 = CPyObject_GetAttr(r60, r61)
    if is_error(r62) goto L51 (error at <module>:41) else goto L26
L26:
    r63 = [r59]
    r64 = load_address r63
    r65 = PyObject_Vectorcall(r62, r64, 1, 0)
    dec_ref r62
    if is_error(r65) goto L51 (error at <module>:41) else goto L27
L27:
    dec_ref r59
    r66 = '__new__'
    r67 = CPyDict_SetItem(r56, r66, r65)
    dec_ref r65
    r68 = r67 >= 0 :: signed
    if not r68 goto L50 (error at <module>:41) else goto L28 :: bool
L28:
    r69 = __getitem___HexBytes_obj()
    if is_error(r69) goto L50 (error at <module>:53) else goto L29
L29:
    r70 = '__getitem__'
    r71 = CPyDict_SetItem(r56, r70, r69)
    dec_ref r69
    r72 = r71 >= 0 :: signed
    if not r72 goto L50 (error at <module>:53) else goto L30 :: bool
L30:
    r73 = __repr___HexBytes_obj()
    if is_error(r73) goto L50 (error at <module>:62) else goto L31
L31:
    r74 = '__repr__'
    r75 = CPyDict_SetItem(r56, r74, r73)
    dec_ref r73
    r76 = r75 >= 0 :: signed
    if not r76 goto L50 (error at <module>:62) else goto L32 :: bool
L32:
    r77 = to_0x_hex_HexBytes_obj()
    if is_error(r77) goto L50 (error at <module>:65) else goto L33
L33:
    r78 = 'to_0x_hex'
    r79 = CPyDict_SetItem(r56, r78, r77)
    dec_ref r77
    r80 = r79 >= 0 :: signed
    if not r80 goto L50 (error at <module>:65) else goto L34 :: bool
L34:
    r81 = __reduce___HexBytes_obj()
    if is_error(r81) goto L50 (error at <module>:71) else goto L35
L35:
    r82 = '__reduce__'
    r83 = CPyDict_SetItem(r56, r82, r81)
    dec_ref r81
    r84 = r83 >= 0 :: signed
    if not r84 goto L50 (error at <module>:71) else goto L36 :: bool
L36:
    r85 = 'HexBytes'
    r86 = '__annotations__'
    r87 = CPyDict_SetItem(r56, r86, r58)
    dec_ref r58
    r88 = r87 >= 0 :: signed
    if not r88 goto L49 (error at <module>:30) else goto L37 :: bool
L37:
    r89 = 'mypyc filler docstring'
    r90 = '__doc__'
    r91 = CPyDict_SetItem(r56, r90, r89)
    r92 = r91 >= 0 :: signed
    if not r92 goto L49 (error at <module>:30) else goto L38 :: bool
L38:
    r93 = 'faster_hexbytes.main'
    r94 = '__module__'
    r95 = CPyDict_SetItem(r56, r94, r93)
    r96 = r95 >= 0 :: signed
    if not r96 goto L49 (error at <module>:30) else goto L39 :: bool
L39:
    r97 = [r85, r44, r56]
    r98 = load_address r97
    r99 = PyObject_Vectorcall(r46, r98, 3, 0)
    if is_error(r99) goto L49 (error at <module>:30) else goto L40
L40:
    dec_ref r56
    dec_ref r44
    r100 = faster_hexbytes.main.globals :: static
    r101 = 'mypyc_attr'
    r102 = CPyDict_GetItem(r100, r101)
    if is_error(r102) goto L52 (error at <module>:29) else goto L41
L41:
    r103 = box(bool, 0)
    r104 = [r103]
    r105 = load_address r104
    r106 = ('native_class',)
    r107 = PyObject_Vectorcall(r102, r105, 0, r106)
    dec_ref r102
    if is_error(r107) goto L52 (error at <module>:29) else goto L42
L42:
    r108 = [r99]
    r109 = load_address r108
    r110 = PyObject_Vectorcall(r107, r109, 1, 0)
    dec_ref r107
    if is_error(r110) goto L52 (error at <module>:30) else goto L43
L43:
    dec_ref r99
    faster_hexbytes.main.HexBytes = r110 :: type
    r111 = faster_hexbytes.main.globals :: static
    r112 = 'HexBytes'
    r113 = PyDict_SetItem(r111, r112, r110)
    dec_ref r110
    r114 = r113 >= 0 :: signed
    if not r114 goto L45 (error at <module>:30) else goto L44 :: bool
L44:
    r115 = faster_hexbytes.main.HexBytes :: type
    return 1
L45:
    r116 = <error> :: None
    return r116
L46:
    dec_ref r23
    goto L45
L47:
    dec_ref r23
    dec_ref r27
    goto L45
L48:
    dec_ref r44
    goto L45
L49:
    dec_ref r44
    dec_ref r56
    goto L45
L50:
    dec_ref r44
    dec_ref r56
    dec_ref r58
    goto L45
L51:
    dec_ref r44
    dec_ref r56
    dec_ref r58
    dec_ref r59
    goto L45
L52:
    dec_ref r99
    goto L45

def to_bytes(val):
    val :: union[bool, object, bytes, int, str]
    r0 :: bit
    r1 :: bytes
    r2 :: bit
    r3 :: str
    r4 :: bytes
    r5 :: bit
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: bytes
    r11 :: bit
    r12 :: bool
    r13, r14, r15 :: bytes
    r16 :: bit
    r17 :: int
    r18 :: native_int
    r19 :: bit
    r20 :: native_int
    r21, r22 :: bit
    r23 :: bool
    r24 :: bit
    r25 :: str
    r26 :: int
    r27, r28, r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: int
    r37 :: object
    r38 :: str
    r39, r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: str
    r45 :: bytes
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: bool
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55 :: object
    r56 :: bytes
    r57, r58, r59, r60, r61 :: str
    r62 :: object[3]
    r63 :: object_ptr
    r64 :: object
    r65, r66 :: str
    r67 :: object
    r68, r69 :: str
    r70 :: object[3]
    r71 :: object_ptr
    r72 :: object
    r73 :: str
    r74 :: list
    r75, r76, r77, r78, r79, r80 :: ptr
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object
    r85 :: object[1]
    r86 :: object_ptr
    r87 :: object
    r88 :: bytes
L0:
    r0 = PyBytes_Check(val)
    if r0 goto L1 else goto L3 :: bool
L1:
    inc_ref val
    r1 = cast(bytes, val)
    if is_error(r1) goto L51 (error at to_bytes:15) else goto L2
L2:
    return r1
L3:
    r2 = PyUnicode_Check(val)
    if r2 goto L4 else goto L7 :: bool
L4:
    inc_ref val
    r3 = cast(str, val)
    if is_error(r3) goto L51 (error at to_bytes:17) else goto L5
L5:
    r4 = hexstr_to_bytes(r3)
    dec_ref r3
    if is_error(r4) goto L51 (error at to_bytes:17) else goto L6
L6:
    return r4
L7:
    r5 = PyByteArray_Check(val)
    if r5 goto L8 else goto L11 :: bool
L8:
    r6 = load_address PyBytes_Type
    r7 = [val]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r6, r8, 1, 0)
    if is_error(r9) goto L51 (error at to_bytes:19) else goto L9
L9:
    r10 = cast(bytes, r9)
    if is_error(r10) goto L51 (error at to_bytes:19) else goto L10
L10:
    return r10
L11:
    r11 = PyBool_Check(val)
    if r11 goto L12 else goto L17 :: bool
L12:
    r12 = unbox(bool, val)
    if is_error(r12) goto L51 (error at to_bytes:21) else goto L13
L13:
    if r12 goto L14 else goto L15 :: bool
L14:
    r13 = b'\x01'
    inc_ref r13
    r14 = r13
    goto L16
L15:
    r15 = b'\x00'
    inc_ref r15
    r14 = r15
L16:
    return r14
L17:
    r16 = PyLong_Check(val)
    if r16 goto L18 else goto L37 :: bool
L18:
    r17 = unbox(int, val)
    if is_error(r17) goto L51 (error at to_bytes:25) else goto L19
L19:
    r18 = r17 & 1
    r19 = r18 != 0
    if r19 goto L21 else goto L20 :: bool
L20:
    r20 = 0 & 1
    r21 = r20 != 0
    if r21 goto L21 else goto L22 :: bool
L21:
    r22 = CPyTagged_IsLt_(r17, 0)
    r23 = r22
    goto L23
L22:
    r24 = r17 < 0 :: signed
    r23 = r24
L23:
    dec_ref r17 :: int
    if r23 goto L24 else goto L31 :: bool
L24:
    r25 = 'Cannot convert negative integer '
    r26 = unbox(int, val)
    if is_error(r26) goto L51 (error at to_bytes:26) else goto L25
L25:
    r27 = CPyTagged_Str(r26)
    dec_ref r26 :: int
    if is_error(r27) goto L51 (error at to_bytes:26) else goto L26
L26:
    r28 = ' to bytes'
    r29 = CPyStr_Build(3, r25, r27, r28)
    dec_ref r27
    if is_error(r29) goto L51 (error at to_bytes:26) else goto L27
L27:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L52 (error at to_bytes:26) else goto L28
L28:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L52 (error at to_bytes:26) else goto L29
L29:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L51 (error at to_bytes:26) else goto L30 :: bool
L30:
    unreachable
L31:
    r36 = unbox(int, val)
    if is_error(r36) goto L51 (error at to_bytes:28) else goto L32
L32:
    r37 = builtins :: module
    r38 = 'hex'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L53 (error at to_bytes:28) else goto L33
L33:
    r40 = box(int, r36)
    r41 = [r40]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r39, r42, 1, 0)
    dec_ref r39
    if is_error(r43) goto L54 (error at to_bytes:28) else goto L34
L34:
    dec_ref r40
    r44 = cast(str, r43)
    if is_error(r44) goto L51 (error at to_bytes:28) else goto L35
L35:
    r45 = to_bytes(r44)
    dec_ref r44
    if is_error(r45) goto L51 (error at to_bytes:28) else goto L36
L36:
    return r45
L37:
    r46 = builtins :: module
    r47 = 'memoryview'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L51 (error at to_bytes:29) else goto L38
L38:
    r49 = PyObject_IsInstance(val, r48)
    dec_ref r48
    r50 = r49 >= 0 :: signed
    if not r50 goto L51 (error at to_bytes:29) else goto L39 :: bool
L39:
    r51 = truncate r49: i32 to builtins.bool
    if r51 goto L40 else goto L43 :: bool
L40:
    r52 = load_address PyBytes_Type
    r53 = [val]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 1, 0)
    if is_error(r55) goto L51 (error at to_bytes:30) else goto L41
L41:
    r56 = cast(bytes, r55)
    if is_error(r56) goto L51 (error at to_bytes:30) else goto L42
L42:
    return r56
L43:
    r57 = ''
    r58 = 'Cannot convert '
    r59 = '{!r:{}}'
    r60 = ''
    r61 = 'format'
    r62 = [r59, val, r60]
    r63 = load_address r62
    r64 = PyObject_VectorcallMethod(r61, r63, 9223372036854775811, 0)
    if is_error(r64) goto L51 (error at to_bytes:32) else goto L44
L44:
    r65 = ' of type '
    r66 = '{:{}}'
    r67 = CPy_TYPE(val)
    r68 = ''
    r69 = 'format'
    r70 = [r66, r67, r68]
    r71 = load_address r70
    r72 = PyObject_VectorcallMethod(r69, r71, 9223372036854775811, 0)
    if is_error(r72) goto L55 (error at to_bytes:32) else goto L45
L45:
    dec_ref r67
    r73 = ' to bytes'
    r74 = PyList_New(5)
    if is_error(r74) goto L56 (error at to_bytes:32) else goto L46
L46:
    r75 = get_element_ptr r74 ob_item :: PyListObject
    r76 = load_mem r75 :: ptr*
    inc_ref r58
    set_mem r76, r58 :: builtins.object*
    r77 = r76 + 8
    set_mem r77, r64 :: builtins.object*
    inc_ref r65
    r78 = r76 + 16
    set_mem r78, r65 :: builtins.object*
    r79 = r76 + 24
    set_mem r79, r72 :: builtins.object*
    inc_ref r73
    r80 = r76 + 32
    set_mem r80, r73 :: builtins.object*
    r81 = PyUnicode_Join(r57, r74)
    dec_ref r74
    if is_error(r81) goto L51 (error at to_bytes:32) else goto L47
L47:
    r82 = builtins :: module
    r83 = 'TypeError'
    r84 = CPyObject_GetAttr(r82, r83)
    if is_error(r84) goto L57 (error at to_bytes:32) else goto L48
L48:
    r85 = [r81]
    r86 = load_address r85
    r87 = PyObject_Vectorcall(r84, r86, 1, 0)
    dec_ref r84
    if is_error(r87) goto L57 (error at to_bytes:32) else goto L49
L49:
    dec_ref r81
    CPy_Raise(r87)
    dec_ref r87
    if not 0 goto L51 (error at to_bytes:32) else goto L50 :: bool
L50:
    unreachable
L51:
    r88 = <error> :: bytes
    return r88
L52:
    dec_ref r29
    goto L51
L53:
    dec_ref r36 :: int
    goto L51
L54:
    dec_ref r40
    goto L51
L55:
    dec_ref r64
    dec_ref r67
    goto L51
L56:
    dec_ref r64
    dec_ref r72
    goto L51
L57:
    dec_ref r81
    goto L51

def hexstr_to_bytes(hexstr):
    hexstr, r0, r1 :: str
    r2 :: tuple[str, str]
    r3 :: object
    r4 :: bool
    r5 :: object
    r6, non_prefixed_hex :: str
    r7 :: native_int
    r8 :: bit
    r9 :: short_int
    r10 :: int
    r11 :: bit
    r12, r13, padded_hex :: str
    r14 :: bytes
    r15 :: tuple[object, object, object]
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20, r21, r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36, r37 :: bytes
L0:
    r0 = '0x'
    r1 = '0X'
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[str, str], r2)
    r4 = CPyStr_Startswith(hexstr, r3)
    dec_ref r3
    if is_error(r4) goto L29 (error at hexstr_to_bytes:36) else goto L1
L1:
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = CPyStr_GetSlice(hexstr, 4, 9223372036854775806)
    if is_error(r5) goto L29 (error at hexstr_to_bytes:37) else goto L3
L3:
    r6 = cast(str, r5)
    if is_error(r6) goto L29 (error at hexstr_to_bytes:37) else goto L4
L4:
    non_prefixed_hex = r6
    goto L6
L5:
    inc_ref hexstr
    non_prefixed_hex = hexstr
L6:
    r7 = CPyStr_Size_size_t(hexstr)
    r8 = r7 >= 0 :: signed
    if not r8 goto L30 (error at hexstr_to_bytes:42) else goto L7 :: bool
L7:
    r9 = r7 << 1
    r10 = CPyTagged_Remainder(r9, 4)
    if is_error(r10) goto L30 (error at hexstr_to_bytes:42) else goto L8
L8:
    r11 = r10 != 0
    dec_ref r10 :: int
    if r11 goto L9 else goto L11 :: bool
L9:
    r12 = '0'
    r13 = PyUnicode_Concat(r12, non_prefixed_hex)
    dec_ref non_prefixed_hex
    if is_error(r13) goto L29 (error at hexstr_to_bytes:43) else goto L10
L10:
    padded_hex = r13
    goto L12
L11:
    padded_hex = non_prefixed_hex
L12:
    r14 = PyUnicode_AsASCIIString(padded_hex)
    if is_error(r14) goto L14 (error at hexstr_to_bytes:48) else goto L31
L13:
    goto L25
L14:
    r15 = CPy_CatchError()
    r16 = builtins :: module
    r17 = 'UnicodeDecodeError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L32 (error at hexstr_to_bytes:49) else goto L15
L15:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L16 else goto L33 :: bool
L16:
    r20 = 'hex string '
    r21 = ' may only contain [0-9a-fA-F] characters'
    r22 = CPyStr_Build(3, r20, padded_hex, r21)
    dec_ref padded_hex
    if is_error(r22) goto L23 (error at hexstr_to_bytes:51) else goto L17
L17:
    r23 = builtins :: module
    r24 = 'ValueError'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L34 (error at hexstr_to_bytes:50) else goto L18
L18:
    r26 = [r22]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L34 (error at hexstr_to_bytes:50) else goto L19
L19:
    dec_ref r22
    CPy_Raise(r28)
    dec_ref r28
    if not 0 goto L23 (error at hexstr_to_bytes:50) else goto L35 :: bool
L20:
    unreachable
L21:
    CPy_Reraise()
    if not 0 goto L23 else goto L36 :: bool
L22:
    unreachable
L23:
    CPy_RestoreExcInfo(r15)
    dec_ref r15
    r29 = CPy_KeepPropagating()
    if not r29 goto L29 else goto L24 :: bool
L24:
    unreachable
L25:
    r30 = binascii :: module
    r31 = 'unhexlify'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L37 (error at hexstr_to_bytes:54) else goto L26
L26:
    r33 = [r14]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L37 (error at hexstr_to_bytes:54) else goto L27
L27:
    dec_ref r14
    r36 = cast(bytes, r35)
    if is_error(r36) goto L29 (error at hexstr_to_bytes:54) else goto L28
L28:
    return r36
L29:
    r37 = <error> :: bytes
    return r37
L30:
    dec_ref non_prefixed_hex
    goto L29
L31:
    dec_ref padded_hex
    goto L13
L32:
    dec_ref padded_hex
    goto L23
L33:
    dec_ref padded_hex
    goto L21
L34:
    dec_ref r22
    goto L23
L35:
    dec_ref r15
    goto L20
L36:
    dec_ref r15
    goto L22
L37:
    dec_ref r14
    goto L29

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L6 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address binascii :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('binascii', 'binascii', 'binascii'),)
    r11 = faster_hexbytes._utils.globals :: static
    r12 = 'faster_hexbytes/_utils.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L6 else goto L4 :: bool
L4:
    r15 = ('Union',)
    r16 = 'typing'
    r17 = faster_hexbytes._utils.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L6 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    return 1
L6:
    r19 = <error> :: None
    return r19

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5, r6 :: object
    r7 :: str
    r8 :: dict
    r9, r10 :: object
    r11 :: str
    r12 :: dict
    r13 :: object
    r14 :: str
    r15 :: list
    r16, r17 :: ptr
    r18 :: dict
    r19 :: str
    r20 :: i32
    r21 :: bit
    r22 :: str
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L12 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('version',)
    r6 = ('__version',)
    r7 = 'importlib.metadata'
    r8 = faster_hexbytes.globals :: static
    r9 = CPyImport_ImportFromMany(r7, r5, r6, r8)
    if is_error(r9) goto L12 (error at <module>:1) else goto L4
L4:
    importlib.metadata = r9 :: module
    dec_ref r9
    r10 = ('HexBytes',)
    r11 = 'faster_hexbytes.main'
    r12 = faster_hexbytes.globals :: static
    r13 = CPyImport_ImportFromMany(r11, r10, r10, r12)
    if is_error(r13) goto L12 (error at <module>:5) else goto L5
L5:
    faster_hexbytes.main = r13 :: module
    dec_ref r13
    r14 = 'HexBytes'
    r15 = PyList_New(1)
    if is_error(r15) goto L12 (error at <module>:9) else goto L6
L6:
    r16 = get_element_ptr r15 ob_item :: PyListObject
    r17 = load_mem r16 :: ptr*
    inc_ref r14
    set_mem r17, r14 :: builtins.object*
    r18 = faster_hexbytes.globals :: static
    r19 = '__all__'
    r20 = CPyDict_SetItem(r18, r19, r15)
    dec_ref r15
    r21 = r20 >= 0 :: signed
    if not r21 goto L12 (error at <module>:9) else goto L7 :: bool
L7:
    r22 = 'hexbytes'
    r23 = faster_hexbytes.globals :: static
    r24 = '__version'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L12 (error at <module>:11) else goto L8
L8:
    r26 = [r22]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L12 (error at <module>:11) else goto L9
L9:
    r29 = cast(str, r28)
    if is_error(r29) goto L12 (error at <module>:11) else goto L10
L10:
    r30 = faster_hexbytes.globals :: static
    r31 = '__version__'
    r32 = CPyDict_SetItem(r30, r31, r29)
    dec_ref r29
    r33 = r32 >= 0 :: signed
    if not r33 goto L12 (error at <module>:11) else goto L11 :: bool
L11:
    return 1
L12:
    r34 = <error> :: None
    return r34
