def __new___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __new___HexBytes_obj.__call__(__mypyc_self__, cls, val):
    __mypyc_self__ :: faster_hexbytes.main.__new___HexBytes_obj
    cls :: object
    val :: union[bytes, str, bool, object, int]
    r0 :: bytes
    r1 :: object
    r2 :: bool
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: faster_hexbytes.main.HexBytes
L0:
    r0 = to_bytes(val)
    if is_error(r0) goto L7 (error at __new__:49) else goto L1
L1:
    r1 = faster_hexbytes.main._bytes_new :: static
    if is_error(r1) goto L8 else goto L4
L2:
    r2 = raise NameError('value for final name "_bytes_new" was not set')
    if not r2 goto L7 (error at __new__:50) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = [cls, r0]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r1, r4, 2, 0)
    if is_error(r5) goto L9 (error at __new__:50) else goto L5
L5:
    dec_ref r0
    r6 = cast(faster_hexbytes.main.HexBytes, r5)
    if is_error(r6) goto L7 (error at __new__:50) else goto L6
L6:
    return r6
L7:
    r7 = <error> :: faster_hexbytes.main.HexBytes
    return r7
L8:
    dec_ref r0
    goto L2
L9:
    dec_ref r0
    goto L7

def __getitem___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __getitem___HexBytes_obj.__call__(__mypyc_self__, self, key):
    __mypyc_self__ :: faster_hexbytes.main.__getitem___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    key, r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: union[int, bytes]
    r6 :: bit
    r7 :: int
    r8, r9, r10 :: object
    r11 :: bit
    r12 :: bytes
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: faster_hexbytes.main.HexBytes
    r18 :: bytes
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: faster_hexbytes.main.HexBytes
    r23 :: union[int, faster_hexbytes.main.HexBytes]
L0:
    r0 = load_address PyBytes_Type
    r1 = '__getitem__'
    r2 = [r0, self, key]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L14 (error at __getitem__:63) else goto L1
L1:
    r5 = cast(union[int, bytes], r4)
    if is_error(r5) goto L14 (error at __getitem__:63) else goto L2
L2:
    r6 = PyLong_Check(r5)
    if r6 goto L3 else goto L5 :: bool
L3:
    r7 = unbox(int, r5)
    dec_ref r5
    if is_error(r7) goto L14 (error at __getitem__:65) else goto L4
L4:
    r8 = box(int, r7)
    return r8
L5:
    r9 = CPy_TYPE(self)
    r10 = faster_hexbytes.main.HexBytes :: type
    r11 = r9 == r10
    if r11 goto L15 else goto L10 :: bool
L6:
    r12 = cast(bytes, r5)
    if is_error(r12) goto L14 (error at __getitem__:69) else goto L7
L7:
    r13 = faster_hexbytes.main.HexBytes :: type
    r14 = [r12]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    if is_error(r16) goto L16 (error at __getitem__:69) else goto L8
L8:
    dec_ref r12
    r17 = cast(faster_hexbytes.main.HexBytes, r16)
    if is_error(r17) goto L14 (error at __getitem__:69) else goto L9
L9:
    return r17
L10:
    r18 = cast(bytes, r5)
    if is_error(r18) goto L17 (error at __getitem__:70) else goto L11
L11:
    r19 = [r18]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r9, r20, 1, 0)
    dec_ref r9
    if is_error(r21) goto L18 (error at __getitem__:70) else goto L12
L12:
    dec_ref r18
    r22 = cast(faster_hexbytes.main.HexBytes, r21)
    if is_error(r22) goto L14 (error at __getitem__:70) else goto L13
L13:
    return r22
L14:
    r23 = <error> :: union[int, faster_hexbytes.main.HexBytes]
    return r23
L15:
    dec_ref r9
    goto L6
L16:
    dec_ref r12
    goto L14
L17:
    dec_ref r9
    goto L14
L18:
    dec_ref r18
    goto L14

def __repr___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __repr___HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.__repr___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0, r1, r2, r3, r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8, r9, r10, r11 :: str
    r12 :: object[3]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: str
    r17 :: list
    r18, r19, r20, r21 :: ptr
    r22, r23 :: str
L0:
    r0 = ''
    r1 = 'HexBytes('
    r2 = '{!r:{}}'
    r3 = '0x'
    r4 = 'hex'
    r5 = [self]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L8 (error at __repr__:73) else goto L1
L1:
    r8 = cast(str, r7)
    if is_error(r8) goto L8 (error at __repr__:73) else goto L2
L2:
    r9 = PyUnicode_Concat(r3, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at __repr__:73) else goto L3
L3:
    r10 = ''
    r11 = 'format'
    r12 = [r2, r9, r10]
    r13 = load_address r12
    r14 = PyObject_VectorcallMethod(r11, r13, 9223372036854775811, 0)
    if is_error(r14) goto L9 (error at __repr__:73) else goto L4
L4:
    dec_ref r9
    r15 = cast(str, r14)
    if is_error(r15) goto L8 (error at __repr__:73) else goto L5
L5:
    r16 = ')'
    r17 = PyList_New(3)
    if is_error(r17) goto L10 (error at __repr__:73) else goto L6
L6:
    r18 = get_element_ptr r17 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r1
    set_mem r19, r1 :: builtins.object*
    r20 = r19 + 8
    set_mem r20, r15 :: builtins.object*
    inc_ref r16
    r21 = r19 + 16
    set_mem r21, r16 :: builtins.object*
    r22 = PyUnicode_Join(r0, r17)
    dec_ref r17
    if is_error(r22) goto L8 (error at __repr__:73) else goto L7
L7:
    return r22
L8:
    r23 = <error> :: str
    return r23
L9:
    dec_ref r9
    goto L8
L10:
    dec_ref r15
    goto L8

def to_0x_hex_HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def to_0x_hex_HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.to_0x_hex_HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0, r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: str
L0:
    r0 = '0x'
    r1 = 'hex'
    r2 = [self]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L4 (error at to_0x_hex:79) else goto L1
L1:
    r5 = cast(str, r4)
    if is_error(r5) goto L4 (error at to_0x_hex:79) else goto L2
L2:
    r6 = CPyStr_Build(2, r0, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at to_0x_hex:79) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: str
    return r7

def __reduce___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __reduce___HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.__reduce___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0 :: object
    r1 :: bool
    r2, r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bytes
    r8 :: tuple[object, bytes]
    r9, r10 :: tuple[object, tuple[object, bytes]]
L0:
    r0 = faster_hexbytes.main._bytes_new :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_bytes_new" was not set')
    if not r1 goto L6 (error at __reduce__:89) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = CPy_TYPE(self)
    r3 = load_address PyBytes_Type
    r4 = [self]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    if is_error(r6) goto L7 (error at __reduce__:89) else goto L4
L4:
    r7 = cast(bytes, r6)
    if is_error(r7) goto L7 (error at __reduce__:89) else goto L5
L5:
    r8 = (r2, r7)
    inc_ref r0
    r9 = (r0, r8)
    return r9
L6:
    r10 = <error> :: tuple[object, tuple[object, bytes]]
    return r10
L7:
    dec_ref r2
    goto L6

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30 :: object
    r31 :: dict
    r32 :: str
    r33, r34, r35, r36, r37 :: object
    r38 :: str
    r39, r40, r41 :: object
    r42 :: str
    r43 :: object
    r44 :: tuple[object, object, object, object, object, object]
    r45, r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: tuple
    r62, r63 :: object
    r64 :: str
    r65 :: bool
    r66, r67 :: str
    r68 :: object
    r69 :: object[2]
    r70 :: object_ptr
    r71 :: object
    r72, r73, r74, r75 :: dict
    r76 :: faster_hexbytes.main.__new___HexBytes_obj
    r77 :: object
    r78 :: str
    r79 :: object
    r80 :: object[1]
    r81 :: object_ptr
    r82 :: object
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: faster_hexbytes.main.__getitem___HexBytes_obj
    r87 :: str
    r88 :: i32
    r89 :: bit
    r90 :: faster_hexbytes.main.__repr___HexBytes_obj
    r91 :: str
    r92 :: i32
    r93 :: bit
    r94 :: faster_hexbytes.main.to_0x_hex_HexBytes_obj
    r95 :: str
    r96 :: i32
    r97 :: bit
    r98 :: faster_hexbytes.main.__reduce___HexBytes_obj
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102, r103 :: str
    r104 :: i32
    r105 :: bit
    r106, r107 :: str
    r108 :: i32
    r109 :: bit
    r110, r111 :: str
    r112 :: i32
    r113 :: bit
    r114 :: object[3]
    r115 :: object_ptr
    r116 :: object
    r117 :: dict
    r118 :: str
    r119, r120 :: object
    r121 :: object[1]
    r122 :: object_ptr
    r123, r124 :: object
    r125 :: object[1]
    r126 :: object_ptr
    r127 :: object
    r128 :: dict
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: object
    r133 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L48 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Callable', 'Final', 'Tuple', 'Type', 'Union', 'overload')
    r6 = 'typing'
    r7 = faster_hexbytes.main.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L48 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address hexbytes.main :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [14]
    r13 = load_address r12
    r14 = (('hexbytes.main', 'hexbytes.main', 'hexbytes'),)
    r15 = faster_hexbytes.main.globals :: static
    r16 = 'faster_hexbytes/main.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L48 else goto L5 :: bool
L5:
    r19 = ('mypyc_attr',)
    r20 = 'mypy_extensions'
    r21 = faster_hexbytes.main.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L48 (error at <module>:15) else goto L6
L6:
    mypy_extensions = r22 :: module
    dec_ref r22
    r23 = ('Self',)
    r24 = 'typing_extensions'
    r25 = faster_hexbytes.main.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L48 (error at <module>:18) else goto L7
L7:
    typing_extensions = r26 :: module
    dec_ref r26
    r27 = ('to_bytes',)
    r28 = 'faster_hexbytes._utils'
    r29 = faster_hexbytes.main.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L48 (error at <module>:22) else goto L8
L8:
    faster_hexbytes._utils = r30 :: module
    dec_ref r30
    if 0 goto L9 else goto L9 :: bool
L9:
    r31 = faster_hexbytes.main.globals :: static
    r32 = 'Union'
    r33 = CPyDict_GetItem(r31, r32)
    if is_error(r33) goto L48 (error at <module>:31) else goto L10
L10:
    r34 = load_address PyBytes_Type
    r35 = load_address PyUnicode_Type
    r36 = load_address PyBool_Type
    r37 = builtins :: module
    r38 = 'bytearray'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L49 (error at <module>:31) else goto L11
L11:
    r40 = load_address PyLong_Type
    r41 = builtins :: module
    r42 = 'memoryview'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L50 (error at <module>:31) else goto L12
L12:
    inc_ref r34
    inc_ref r35
    inc_ref r36
    inc_ref r40
    r44 = (r34, r35, r36, r39, r40, r43)
    r45 = box(tuple[object, object, object, object, object, object], r44)
    r46 = PyObject_GetItem(r33, r45)
    dec_ref r33
    dec_ref r45
    if is_error(r46) goto L48 (error at <module>:31) else goto L13
L13:
    r47 = faster_hexbytes.main.globals :: static
    r48 = 'BytesLike'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L48 (error at <module>:31) else goto L14 :: bool
L14:
    r51 = load_address PyBytes_Type
    r52 = '__new__'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L48 (error at <module>:33) else goto L15
L15:
    faster_hexbytes.main._bytes_new = r53 :: static
    r54 = faster_hexbytes.main.globals :: static
    r55 = '_bytes_new'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L48 (error at <module>:33) else goto L16 :: bool
L16:
    r58 = hexbytes.main :: module
    r59 = 'HexBytes'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L48 (error at <module>:37) else goto L17
L17:
    r61 = PyTuple_Pack(1, r60)
    dec_ref r60
    if is_error(r61) goto L48 (error at <module>:37) else goto L18
L18:
    r62 = load_address PyType_Type
    r63 = CPy_CalculateMetaclass(r62, r61)
    if is_error(r63) goto L51 (error at <module>:37) else goto L19
L19:
    r64 = '__prepare__'
    r65 = PyObject_HasAttr(r63, r64)
    if r65 goto L20 else goto L24 :: bool
L20:
    r66 = 'HexBytes'
    r67 = '__prepare__'
    r68 = CPyObject_GetAttr(r63, r67)
    if is_error(r68) goto L51 (error at <module>:37) else goto L21
L21:
    r69 = [r66, r61]
    r70 = load_address r69
    r71 = PyObject_Vectorcall(r68, r70, 2, 0)
    dec_ref r68
    if is_error(r71) goto L51 (error at <module>:37) else goto L22
L22:
    r72 = cast(dict, r71)
    if is_error(r72) goto L51 (error at <module>:37) else goto L23
L23:
    r73 = r72
    goto L26
L24:
    r74 = PyDict_New()
    if is_error(r74) goto L51 (error at <module>:37) else goto L25
L25:
    r73 = r74
L26:
    r75 = PyDict_New()
    if is_error(r75) goto L52 (error at <module>:37) else goto L27
L27:
    r76 = __new___HexBytes_obj()
    if is_error(r76) goto L53 (error at <module>:48) else goto L28
L28:
    r77 = builtins :: module
    r78 = 'staticmethod'
    r79 = CPyObject_GetAttr(r77, r78)
    if is_error(r79) goto L54 (error at <module>:48) else goto L29
L29:
    r80 = [r76]
    r81 = load_address r80
    r82 = PyObject_Vectorcall(r79, r81, 1, 0)
    dec_ref r79
    if is_error(r82) goto L54 (error at <module>:48) else goto L30
L30:
    dec_ref r76
    r83 = '__new__'
    r84 = CPyDict_SetItem(r73, r83, r82)
    dec_ref r82
    r85 = r84 >= 0 :: signed
    if not r85 goto L53 (error at <module>:48) else goto L31 :: bool
L31:
    r86 = __getitem___HexBytes_obj()
    if is_error(r86) goto L53 (error at <module>:60) else goto L32
L32:
    r87 = '__getitem__'
    r88 = CPyDict_SetItem(r73, r87, r86)
    dec_ref r86
    r89 = r88 >= 0 :: signed
    if not r89 goto L53 (error at <module>:60) else goto L33 :: bool
L33:
    r90 = __repr___HexBytes_obj()
    if is_error(r90) goto L53 (error at <module>:72) else goto L34
L34:
    r91 = '__repr__'
    r92 = CPyDict_SetItem(r73, r91, r90)
    dec_ref r90
    r93 = r92 >= 0 :: signed
    if not r93 goto L53 (error at <module>:72) else goto L35 :: bool
L35:
    r94 = to_0x_hex_HexBytes_obj()
    if is_error(r94) goto L53 (error at <module>:75) else goto L36
L36:
    r95 = 'to_0x_hex'
    r96 = CPyDict_SetItem(r73, r95, r94)
    dec_ref r94
    r97 = r96 >= 0 :: signed
    if not r97 goto L53 (error at <module>:75) else goto L37 :: bool
L37:
    r98 = __reduce___HexBytes_obj()
    if is_error(r98) goto L53 (error at <module>:81) else goto L38
L38:
    r99 = '__reduce__'
    r100 = CPyDict_SetItem(r73, r99, r98)
    dec_ref r98
    r101 = r100 >= 0 :: signed
    if not r101 goto L53 (error at <module>:81) else goto L39 :: bool
L39:
    r102 = 'HexBytes'
    r103 = '__annotations__'
    r104 = CPyDict_SetItem(r73, r103, r75)
    dec_ref r75
    r105 = r104 >= 0 :: signed
    if not r105 goto L52 (error at <module>:37) else goto L40 :: bool
L40:
    r106 = 'mypyc filler docstring'
    r107 = '__doc__'
    r108 = CPyDict_SetItem(r73, r107, r106)
    r109 = r108 >= 0 :: signed
    if not r109 goto L52 (error at <module>:37) else goto L41 :: bool
L41:
    r110 = 'faster_hexbytes.main'
    r111 = '__module__'
    r112 = CPyDict_SetItem(r73, r111, r110)
    r113 = r112 >= 0 :: signed
    if not r113 goto L52 (error at <module>:37) else goto L42 :: bool
L42:
    r114 = [r102, r61, r73]
    r115 = load_address r114
    r116 = PyObject_Vectorcall(r63, r115, 3, 0)
    if is_error(r116) goto L52 (error at <module>:37) else goto L43
L43:
    dec_ref r73
    dec_ref r61
    r117 = faster_hexbytes.main.globals :: static
    r118 = 'mypyc_attr'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L55 (error at <module>:36) else goto L44
L44:
    r120 = box(bool, 0)
    r121 = [r120]
    r122 = load_address r121
    r123 = ('native_class',)
    r124 = PyObject_Vectorcall(r119, r122, 0, r123)
    dec_ref r119
    if is_error(r124) goto L55 (error at <module>:36) else goto L45
L45:
    r125 = [r116]
    r126 = load_address r125
    r127 = PyObject_Vectorcall(r124, r126, 1, 0)
    dec_ref r124
    if is_error(r127) goto L55 (error at <module>:37) else goto L46
L46:
    dec_ref r116
    faster_hexbytes.main.HexBytes = r127 :: type
    r128 = faster_hexbytes.main.globals :: static
    r129 = 'HexBytes'
    r130 = PyDict_SetItem(r128, r129, r127)
    dec_ref r127
    r131 = r130 >= 0 :: signed
    if not r131 goto L48 (error at <module>:37) else goto L47 :: bool
L47:
    r132 = faster_hexbytes.main.HexBytes :: type
    return 1
L48:
    r133 = <error> :: None
    return r133
L49:
    dec_ref r33
    goto L48
L50:
    dec_ref r33
    dec_ref r39
    goto L48
L51:
    dec_ref r61
    goto L48
L52:
    dec_ref r61
    dec_ref r73
    goto L48
L53:
    dec_ref r61
    dec_ref r73
    dec_ref r75
    goto L48
L54:
    dec_ref r61
    dec_ref r73
    dec_ref r75
    dec_ref r76
    goto L48
L55:
    dec_ref r116
    goto L48

def to_bytes(val):
    val :: union[bytes, str, object, bool, int]
    r0 :: bit
    r1 :: bytes
    r2 :: bit
    r3 :: str
    r4 :: bytes
    r5 :: bit
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: bytes
    r11 :: bit
    r12 :: bool
    r13, r14, r15 :: bytes
    r16 :: bit
    r17 :: int
    r18 :: native_int
    r19 :: bit
    r20 :: native_int
    r21, r22 :: bit
    r23 :: bool
    r24 :: bit
    r25 :: str
    r26 :: int
    r27, r28, r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: int
    r37 :: object
    r38 :: str
    r39, r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: str
    r45 :: bytes
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: bool
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55 :: object
    r56 :: bytes
    r57, r58, r59, r60, r61 :: str
    r62 :: object[3]
    r63 :: object_ptr
    r64 :: object
    r65, r66 :: str
    r67 :: object
    r68, r69 :: str
    r70 :: object[3]
    r71 :: object_ptr
    r72 :: object
    r73 :: str
    r74 :: list
    r75, r76, r77, r78, r79, r80 :: ptr
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object
    r85 :: object[1]
    r86 :: object_ptr
    r87 :: object
    r88 :: bytes
L0:
    r0 = PyBytes_Check(val)
    if r0 goto L1 else goto L3 :: bool
L1:
    inc_ref val
    r1 = cast(bytes, val)
    if is_error(r1) goto L51 (error at to_bytes:19) else goto L2
L2:
    return r1
L3:
    r2 = PyUnicode_Check(val)
    if r2 goto L4 else goto L7 :: bool
L4:
    inc_ref val
    r3 = cast(str, val)
    if is_error(r3) goto L51 (error at to_bytes:21) else goto L5
L5:
    r4 = hexstr_to_bytes(r3)
    dec_ref r3
    if is_error(r4) goto L51 (error at to_bytes:21) else goto L6
L6:
    return r4
L7:
    r5 = PyByteArray_Check(val)
    if r5 goto L8 else goto L11 :: bool
L8:
    r6 = load_address PyBytes_Type
    r7 = [val]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r6, r8, 1, 0)
    if is_error(r9) goto L51 (error at to_bytes:23) else goto L9
L9:
    r10 = cast(bytes, r9)
    if is_error(r10) goto L51 (error at to_bytes:23) else goto L10
L10:
    return r10
L11:
    r11 = PyBool_Check(val)
    if r11 goto L12 else goto L17 :: bool
L12:
    r12 = unbox(bool, val)
    if is_error(r12) goto L51 (error at to_bytes:25) else goto L13
L13:
    if r12 goto L14 else goto L15 :: bool
L14:
    r13 = b'\x01'
    inc_ref r13
    r14 = r13
    goto L16
L15:
    r15 = b'\x00'
    inc_ref r15
    r14 = r15
L16:
    return r14
L17:
    r16 = PyLong_Check(val)
    if r16 goto L18 else goto L37 :: bool
L18:
    r17 = unbox(int, val)
    if is_error(r17) goto L51 (error at to_bytes:29) else goto L19
L19:
    r18 = r17 & 1
    r19 = r18 != 0
    if r19 goto L21 else goto L20 :: bool
L20:
    r20 = 0 & 1
    r21 = r20 != 0
    if r21 goto L21 else goto L22 :: bool
L21:
    r22 = CPyTagged_IsLt_(r17, 0)
    r23 = r22
    goto L23
L22:
    r24 = r17 < 0 :: signed
    r23 = r24
L23:
    dec_ref r17 :: int
    if r23 goto L24 else goto L31 :: bool
L24:
    r25 = 'Cannot convert negative integer '
    r26 = unbox(int, val)
    if is_error(r26) goto L51 (error at to_bytes:30) else goto L25
L25:
    r27 = CPyTagged_Str(r26)
    dec_ref r26 :: int
    if is_error(r27) goto L51 (error at to_bytes:30) else goto L26
L26:
    r28 = ' to bytes'
    r29 = CPyStr_Build(3, r25, r27, r28)
    dec_ref r27
    if is_error(r29) goto L51 (error at to_bytes:30) else goto L27
L27:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L52 (error at to_bytes:30) else goto L28
L28:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L52 (error at to_bytes:30) else goto L29
L29:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L51 (error at to_bytes:30) else goto L30 :: bool
L30:
    unreachable
L31:
    r36 = unbox(int, val)
    if is_error(r36) goto L51 (error at to_bytes:32) else goto L32
L32:
    r37 = builtins :: module
    r38 = 'hex'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L53 (error at to_bytes:32) else goto L33
L33:
    r40 = box(int, r36)
    r41 = [r40]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r39, r42, 1, 0)
    dec_ref r39
    if is_error(r43) goto L54 (error at to_bytes:32) else goto L34
L34:
    dec_ref r40
    r44 = cast(str, r43)
    if is_error(r44) goto L51 (error at to_bytes:32) else goto L35
L35:
    r45 = to_bytes(r44)
    dec_ref r44
    if is_error(r45) goto L51 (error at to_bytes:32) else goto L36
L36:
    return r45
L37:
    r46 = builtins :: module
    r47 = 'memoryview'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L51 (error at to_bytes:33) else goto L38
L38:
    r49 = PyObject_IsInstance(val, r48)
    dec_ref r48
    r50 = r49 >= 0 :: signed
    if not r50 goto L51 (error at to_bytes:33) else goto L39 :: bool
L39:
    r51 = truncate r49: i32 to builtins.bool
    if r51 goto L40 else goto L43 :: bool
L40:
    r52 = load_address PyBytes_Type
    r53 = [val]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 1, 0)
    if is_error(r55) goto L51 (error at to_bytes:34) else goto L41
L41:
    r56 = cast(bytes, r55)
    if is_error(r56) goto L51 (error at to_bytes:34) else goto L42
L42:
    return r56
L43:
    r57 = ''
    r58 = 'Cannot convert '
    r59 = '{!r:{}}'
    r60 = ''
    r61 = 'format'
    r62 = [r59, val, r60]
    r63 = load_address r62
    r64 = PyObject_VectorcallMethod(r61, r63, 9223372036854775811, 0)
    if is_error(r64) goto L51 (error at to_bytes:36) else goto L44
L44:
    r65 = ' of type '
    r66 = '{:{}}'
    r67 = CPy_TYPE(val)
    r68 = ''
    r69 = 'format'
    r70 = [r66, r67, r68]
    r71 = load_address r70
    r72 = PyObject_VectorcallMethod(r69, r71, 9223372036854775811, 0)
    if is_error(r72) goto L55 (error at to_bytes:36) else goto L45
L45:
    dec_ref r67
    r73 = ' to bytes'
    r74 = PyList_New(5)
    if is_error(r74) goto L56 (error at to_bytes:36) else goto L46
L46:
    r75 = get_element_ptr r74 ob_item :: PyListObject
    r76 = load_mem r75 :: ptr*
    inc_ref r58
    set_mem r76, r58 :: builtins.object*
    r77 = r76 + 8
    set_mem r77, r64 :: builtins.object*
    inc_ref r65
    r78 = r76 + 16
    set_mem r78, r65 :: builtins.object*
    r79 = r76 + 24
    set_mem r79, r72 :: builtins.object*
    inc_ref r73
    r80 = r76 + 32
    set_mem r80, r73 :: builtins.object*
    r81 = PyUnicode_Join(r57, r74)
    dec_ref r74
    if is_error(r81) goto L51 (error at to_bytes:36) else goto L47
L47:
    r82 = builtins :: module
    r83 = 'TypeError'
    r84 = CPyObject_GetAttr(r82, r83)
    if is_error(r84) goto L57 (error at to_bytes:36) else goto L48
L48:
    r85 = [r81]
    r86 = load_address r85
    r87 = PyObject_Vectorcall(r84, r86, 1, 0)
    dec_ref r84
    if is_error(r87) goto L57 (error at to_bytes:36) else goto L49
L49:
    dec_ref r81
    CPy_Raise(r87)
    dec_ref r87
    if not 0 goto L51 (error at to_bytes:36) else goto L50 :: bool
L50:
    unreachable
L51:
    r88 = <error> :: bytes
    return r88
L52:
    dec_ref r29
    goto L51
L53:
    dec_ref r36 :: int
    goto L51
L54:
    dec_ref r40
    goto L51
L55:
    dec_ref r64
    dec_ref r67
    goto L51
L56:
    dec_ref r64
    dec_ref r72
    goto L51
L57:
    dec_ref r81
    goto L51

def hexstr_to_bytes(hexstr):
    hexstr, r0, r1 :: str
    r2 :: tuple[str, str]
    r3 :: object
    r4 :: bool
    r5 :: object
    r6, non_prefixed_hex :: str
    r7 :: native_int
    r8 :: bit
    r9 :: short_int
    r10 :: int
    r11 :: bit
    r12, r13, padded_hex :: str
    r14 :: bytes
    r15 :: tuple[object, object, object]
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20, r21, r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35, r36 :: bytes
L0:
    r0 = '0x'
    r1 = '0X'
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[str, str], r2)
    r4 = CPyStr_Startswith(hexstr, r3)
    dec_ref r3
    if is_error(r4) goto L31 (error at hexstr_to_bytes:40) else goto L1
L1:
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = CPyStr_GetSlice(hexstr, 4, 9223372036854775806)
    if is_error(r5) goto L31 (error at hexstr_to_bytes:41) else goto L3
L3:
    r6 = cast(str, r5)
    if is_error(r6) goto L31 (error at hexstr_to_bytes:41) else goto L4
L4:
    non_prefixed_hex = r6
    goto L6
L5:
    inc_ref hexstr
    non_prefixed_hex = hexstr
L6:
    r7 = CPyStr_Size_size_t(hexstr)
    r8 = r7 >= 0 :: signed
    if not r8 goto L32 (error at hexstr_to_bytes:46) else goto L7 :: bool
L7:
    r9 = r7 << 1
    r10 = CPyTagged_Remainder(r9, 4)
    if is_error(r10) goto L32 (error at hexstr_to_bytes:46) else goto L8
L8:
    r11 = r10 != 0
    dec_ref r10 :: int
    if r11 goto L9 else goto L11 :: bool
L9:
    r12 = '0'
    r13 = PyUnicode_Concat(r12, non_prefixed_hex)
    dec_ref non_prefixed_hex
    if is_error(r13) goto L31 (error at hexstr_to_bytes:47) else goto L10
L10:
    padded_hex = r13
    goto L12
L11:
    padded_hex = non_prefixed_hex
L12:
    r14 = PyUnicode_AsASCIIString(padded_hex)
    if is_error(r14) goto L14 (error at hexstr_to_bytes:52) else goto L33
L13:
    goto L25
L14:
    r15 = CPy_CatchError()
    r16 = builtins :: module
    r17 = 'UnicodeDecodeError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L34 (error at hexstr_to_bytes:53) else goto L15
L15:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L16 else goto L35 :: bool
L16:
    r20 = 'hex string '
    r21 = ' may only contain [0-9a-fA-F] characters'
    r22 = CPyStr_Build(3, r20, padded_hex, r21)
    dec_ref padded_hex
    if is_error(r22) goto L23 (error at hexstr_to_bytes:55) else goto L17
L17:
    r23 = builtins :: module
    r24 = 'ValueError'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L36 (error at hexstr_to_bytes:54) else goto L18
L18:
    r26 = [r22]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L36 (error at hexstr_to_bytes:54) else goto L19
L19:
    dec_ref r22
    CPy_Raise(r28)
    dec_ref r28
    if not 0 goto L23 (error at hexstr_to_bytes:54) else goto L37 :: bool
L20:
    unreachable
L21:
    CPy_Reraise()
    if not 0 goto L23 else goto L38 :: bool
L22:
    unreachable
L23:
    CPy_RestoreExcInfo(r15)
    dec_ref r15
    r29 = CPy_KeepPropagating()
    if not r29 goto L31 else goto L24 :: bool
L24:
    unreachable
L25:
    r30 = faster_hexbytes._utils.unhexlify :: static
    if is_error(r30) goto L39 else goto L28
L26:
    r31 = raise NameError('value for final name "unhexlify" was not set')
    if not r31 goto L31 (error at hexstr_to_bytes:58) else goto L27 :: bool
L27:
    unreachable
L28:
    r32 = [r14]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r30, r33, 1, 0)
    if is_error(r34) goto L40 (error at hexstr_to_bytes:58) else goto L29
L29:
    dec_ref r14
    r35 = cast(bytes, r34)
    if is_error(r35) goto L31 (error at hexstr_to_bytes:58) else goto L30
L30:
    return r35
L31:
    r36 = <error> :: bytes
    return r36
L32:
    dec_ref non_prefixed_hex
    goto L31
L33:
    dec_ref padded_hex
    goto L13
L34:
    dec_ref padded_hex
    goto L23
L35:
    dec_ref padded_hex
    goto L21
L36:
    dec_ref r22
    goto L23
L37:
    dec_ref r15
    goto L20
L38:
    dec_ref r15
    goto L22
L39:
    dec_ref r14
    goto L26
L40:
    dec_ref r14
    goto L31

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: i32
    r25 :: bit
    r26 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address binascii :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('binascii', 'binascii', 'binascii'),)
    r11 = faster_hexbytes._utils.globals :: static
    r12 = 'faster_hexbytes/_utils.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L8 else goto L4 :: bool
L4:
    r15 = ('Final', 'Union')
    r16 = 'typing'
    r17 = faster_hexbytes._utils.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L8 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = binascii :: module
    r20 = 'unhexlify'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L8 (error at <module>:8) else goto L6
L6:
    faster_hexbytes._utils.unhexlify = r21 :: static
    r22 = faster_hexbytes._utils.globals :: static
    r23 = 'unhexlify'
    r24 = CPyDict_SetItem(r22, r23, r21)
    dec_ref r21
    r25 = r24 >= 0 :: signed
    if not r25 goto L8 (error at <module>:8) else goto L7 :: bool
L7:
    return 1
L8:
    r26 = <error> :: None
    return r26

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5, r6 :: object
    r7 :: str
    r8 :: dict
    r9, r10 :: object
    r11 :: str
    r12 :: dict
    r13 :: object
    r14 :: str
    r15 :: list
    r16, r17 :: ptr
    r18 :: dict
    r19 :: str
    r20 :: i32
    r21 :: bit
    r22 :: str
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L12 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('version',)
    r6 = ('__version',)
    r7 = 'importlib.metadata'
    r8 = faster_hexbytes.globals :: static
    r9 = CPyImport_ImportFromMany(r7, r5, r6, r8)
    if is_error(r9) goto L12 (error at <module>:1) else goto L4
L4:
    importlib.metadata = r9 :: module
    dec_ref r9
    r10 = ('HexBytes',)
    r11 = 'faster_hexbytes.main'
    r12 = faster_hexbytes.globals :: static
    r13 = CPyImport_ImportFromMany(r11, r10, r10, r12)
    if is_error(r13) goto L12 (error at <module>:5) else goto L5
L5:
    faster_hexbytes.main = r13 :: module
    dec_ref r13
    r14 = 'HexBytes'
    r15 = PyList_New(1)
    if is_error(r15) goto L12 (error at <module>:9) else goto L6
L6:
    r16 = get_element_ptr r15 ob_item :: PyListObject
    r17 = load_mem r16 :: ptr*
    inc_ref r14
    set_mem r17, r14 :: builtins.object*
    r18 = faster_hexbytes.globals :: static
    r19 = '__all__'
    r20 = CPyDict_SetItem(r18, r19, r15)
    dec_ref r15
    r21 = r20 >= 0 :: signed
    if not r21 goto L12 (error at <module>:9) else goto L7 :: bool
L7:
    r22 = 'hexbytes'
    r23 = faster_hexbytes.globals :: static
    r24 = '__version'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L12 (error at <module>:11) else goto L8
L8:
    r26 = [r22]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L12 (error at <module>:11) else goto L9
L9:
    r29 = cast(str, r28)
    if is_error(r29) goto L12 (error at <module>:11) else goto L10
L10:
    r30 = faster_hexbytes.globals :: static
    r31 = '__version__'
    r32 = CPyDict_SetItem(r30, r31, r29)
    dec_ref r29
    r33 = r32 >= 0 :: signed
    if not r33 goto L12 (error at <module>:11) else goto L11 :: bool
L11:
    return 1
L12:
    r34 = <error> :: None
    return r34
