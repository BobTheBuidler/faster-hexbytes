def __new___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __new___HexBytes_obj.__call__(__mypyc_self__, cls, val):
    __mypyc_self__ :: faster_hexbytes.main.__new___HexBytes_obj
    cls :: object
    val :: union[bytes, str, bool, object, int]
    r0 :: bytes
    r1 :: object
    r2 :: bool
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: faster_hexbytes.main.HexBytes
L0:
    r0 = to_bytes(val)
    if is_error(r0) goto L7 (error at __new__:52) else goto L1
L1:
    r1 = faster_hexbytes.main._bytes_new :: static
    if is_error(r1) goto L8 else goto L4
L2:
    r2 = raise NameError('value for final name "_bytes_new" was not set')
    if not r2 goto L7 (error at __new__:53) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = [cls, r0]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r1, r4, 2, 0)
    if is_error(r5) goto L9 (error at __new__:53) else goto L5
L5:
    dec_ref r0
    r6 = cast(faster_hexbytes.main.HexBytes, r5)
    if is_error(r6) goto L7 (error at __new__:53) else goto L6
L6:
    return r6
L7:
    r7 = <error> :: faster_hexbytes.main.HexBytes
    return r7
L8:
    dec_ref r0
    goto L2
L9:
    dec_ref r0
    goto L7

def __getitem___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __getitem___HexBytes_obj.__call__(__mypyc_self__, self, key):
    __mypyc_self__ :: faster_hexbytes.main.__getitem___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    key, r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: union[int, bytes]
    r6 :: bit
    r7 :: int
    r8, r9, r10 :: object
    r11 :: bit
    r12 :: bytes
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: faster_hexbytes.main.HexBytes
    r18 :: bytes
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: faster_hexbytes.main.HexBytes
    r23 :: union[int, faster_hexbytes.main.HexBytes]
L0:
    r0 = load_address PyBytes_Type
    r1 = '__getitem__'
    r2 = [r0, self, key]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L14 (error at __getitem__:66) else goto L1
L1:
    r5 = cast(union[int, bytes], r4)
    if is_error(r5) goto L14 (error at __getitem__:66) else goto L2
L2:
    r6 = PyLong_Check(r5)
    if r6 goto L3 else goto L5 :: bool
L3:
    r7 = unbox(int, r5)
    dec_ref r5
    if is_error(r7) goto L14 (error at __getitem__:68) else goto L4
L4:
    r8 = box(int, r7)
    return r8
L5:
    r9 = CPy_TYPE(self)
    r10 = faster_hexbytes.main.HexBytes :: type
    r11 = r9 == r10
    if r11 goto L15 else goto L10 :: bool
L6:
    r12 = cast(bytes, r5)
    if is_error(r12) goto L14 (error at __getitem__:72) else goto L7
L7:
    r13 = faster_hexbytes.main.HexBytes :: type
    r14 = [r12]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    if is_error(r16) goto L16 (error at __getitem__:72) else goto L8
L8:
    dec_ref r12
    r17 = cast(faster_hexbytes.main.HexBytes, r16)
    if is_error(r17) goto L14 (error at __getitem__:72) else goto L9
L9:
    return r17
L10:
    r18 = cast(bytes, r5)
    if is_error(r18) goto L17 (error at __getitem__:73) else goto L11
L11:
    r19 = [r18]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r9, r20, 1, 0)
    dec_ref r9
    if is_error(r21) goto L18 (error at __getitem__:73) else goto L12
L12:
    dec_ref r18
    r22 = cast(faster_hexbytes.main.HexBytes, r21)
    if is_error(r22) goto L14 (error at __getitem__:73) else goto L13
L13:
    return r22
L14:
    r23 = <error> :: union[int, faster_hexbytes.main.HexBytes]
    return r23
L15:
    dec_ref r9
    goto L6
L16:
    dec_ref r12
    goto L14
L17:
    dec_ref r9
    goto L14
L18:
    dec_ref r18
    goto L14

def __repr___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __repr___HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.__repr___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0, r1, r2, r3, r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8, r9, r10, r11 :: str
    r12 :: object[3]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: str
    r17 :: list
    r18, r19, r20, r21 :: ptr
    r22, r23 :: str
L0:
    r0 = ''
    r1 = 'HexBytes('
    r2 = '{!r:{}}'
    r3 = '0x'
    r4 = 'hex'
    r5 = [self]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L8 (error at __repr__:76) else goto L1
L1:
    r8 = cast(str, r7)
    if is_error(r8) goto L8 (error at __repr__:76) else goto L2
L2:
    r9 = PyUnicode_Concat(r3, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at __repr__:76) else goto L3
L3:
    r10 = ''
    r11 = 'format'
    r12 = [r2, r9, r10]
    r13 = load_address r12
    r14 = PyObject_VectorcallMethod(r11, r13, 9223372036854775811, 0)
    if is_error(r14) goto L9 (error at __repr__:76) else goto L4
L4:
    dec_ref r9
    r15 = cast(str, r14)
    if is_error(r15) goto L8 (error at __repr__:76) else goto L5
L5:
    r16 = ')'
    r17 = PyList_New(3)
    if is_error(r17) goto L10 (error at __repr__:76) else goto L6
L6:
    r18 = get_element_ptr r17 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r1
    set_mem r19, r1 :: builtins.object*
    r20 = r19 + 8
    set_mem r20, r15 :: builtins.object*
    inc_ref r16
    r21 = r19 + 16
    set_mem r21, r16 :: builtins.object*
    r22 = PyUnicode_Join(r0, r17)
    dec_ref r17
    if is_error(r22) goto L8 (error at __repr__:76) else goto L7
L7:
    return r22
L8:
    r23 = <error> :: str
    return r23
L9:
    dec_ref r9
    goto L8
L10:
    dec_ref r15
    goto L8

def to_0x_hex_HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def to_0x_hex_HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.to_0x_hex_HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0, r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: str
L0:
    r0 = '0x'
    r1 = 'hex'
    r2 = [self]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L4 (error at to_0x_hex:82) else goto L1
L1:
    r5 = cast(str, r4)
    if is_error(r5) goto L4 (error at to_0x_hex:82) else goto L2
L2:
    r6 = CPyStr_Build(2, r0, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at to_0x_hex:82) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: str
    return r7

def __reduce___HexBytes_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __reduce___HexBytes_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_hexbytes.main.__reduce___HexBytes_obj
    self :: faster_hexbytes.main.HexBytes
    r0 :: object
    r1 :: bool
    r2, r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bytes
    r8 :: tuple[object, bytes]
    r9, r10 :: tuple[object, tuple[object, bytes]]
L0:
    r0 = faster_hexbytes.main._bytes_new :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_bytes_new" was not set')
    if not r1 goto L6 (error at __reduce__:92) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = CPy_TYPE(self)
    r3 = load_address PyBytes_Type
    r4 = [self]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    if is_error(r6) goto L7 (error at __reduce__:92) else goto L4
L4:
    r7 = cast(bytes, r6)
    if is_error(r7) goto L7 (error at __reduce__:92) else goto L5
L5:
    r8 = (r2, r7)
    inc_ref r0
    r9 = (r0, r8)
    return r9
L6:
    r10 = <error> :: tuple[object, tuple[object, bytes]]
    return r10
L7:
    dec_ref r2
    goto L6

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30 :: object
    r31 :: dict
    r32 :: str
    r33, r34, r35, r36, r37 :: object
    r38 :: str
    r39, r40, r41 :: object
    r42 :: str
    r43 :: object
    r44 :: tuple[object, object, object, object, object, object]
    r45, r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51, r52 :: str
    r53 :: dict
    r54 :: str
    r55 :: object
    r56 :: object[2]
    r57 :: object_ptr
    r58, r59 :: object
    r60 :: dict
    r61 :: str
    r62 :: i32
    r63 :: bit
    r64 :: object
    r65 :: str
    r66 :: object
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: object
    r72 :: str
    r73 :: object
    r74 :: tuple
    r75, r76 :: object
    r77 :: str
    r78 :: bool
    r79, r80 :: str
    r81 :: object
    r82 :: object[2]
    r83 :: object_ptr
    r84 :: object
    r85, r86, r87, r88 :: dict
    r89 :: faster_hexbytes.main.__new___HexBytes_obj
    r90 :: object
    r91 :: str
    r92 :: object
    r93 :: object[1]
    r94 :: object_ptr
    r95 :: object
    r96 :: str
    r97 :: i32
    r98 :: bit
    r99 :: faster_hexbytes.main.__getitem___HexBytes_obj
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: faster_hexbytes.main.__repr___HexBytes_obj
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: faster_hexbytes.main.to_0x_hex_HexBytes_obj
    r108 :: str
    r109 :: i32
    r110 :: bit
    r111 :: faster_hexbytes.main.__reduce___HexBytes_obj
    r112 :: str
    r113 :: i32
    r114 :: bit
    r115, r116 :: str
    r117 :: i32
    r118 :: bit
    r119, r120 :: str
    r121 :: i32
    r122 :: bit
    r123, r124 :: str
    r125 :: i32
    r126 :: bit
    r127 :: object[3]
    r128 :: object_ptr
    r129 :: object
    r130 :: dict
    r131 :: str
    r132, r133 :: object
    r134 :: object[1]
    r135 :: object_ptr
    r136, r137 :: object
    r138 :: object[1]
    r139 :: object_ptr
    r140 :: object
    r141 :: dict
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: object
    r146 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L51 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Callable', 'Final', 'Tuple', 'Type', 'TypeVar', 'Union', 'overload')
    r6 = 'typing'
    r7 = faster_hexbytes.main.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L51 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address hexbytes.main :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [15]
    r13 = load_address r12
    r14 = (('hexbytes.main', 'hexbytes.main', 'hexbytes'),)
    r15 = faster_hexbytes.main.globals :: static
    r16 = 'faster_hexbytes/main.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L51 else goto L5 :: bool
L5:
    r19 = ('mypyc_attr',)
    r20 = 'mypy_extensions'
    r21 = faster_hexbytes.main.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L51 (error at <module>:16) else goto L6
L6:
    mypy_extensions = r22 :: module
    dec_ref r22
    r23 = ('Self',)
    r24 = 'typing_extensions'
    r25 = faster_hexbytes.main.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L51 (error at <module>:19) else goto L7
L7:
    typing_extensions = r26 :: module
    dec_ref r26
    r27 = ('to_bytes',)
    r28 = 'faster_hexbytes._utils'
    r29 = faster_hexbytes.main.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L51 (error at <module>:23) else goto L8
L8:
    faster_hexbytes._utils = r30 :: module
    dec_ref r30
    if 0 goto L9 else goto L9 :: bool
L9:
    r31 = faster_hexbytes.main.globals :: static
    r32 = 'Union'
    r33 = CPyDict_GetItem(r31, r32)
    if is_error(r33) goto L51 (error at <module>:32) else goto L10
L10:
    r34 = load_address PyBytes_Type
    r35 = load_address PyUnicode_Type
    r36 = load_address PyBool_Type
    r37 = builtins :: module
    r38 = 'bytearray'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L52 (error at <module>:32) else goto L11
L11:
    r40 = load_address PyLong_Type
    r41 = builtins :: module
    r42 = 'memoryview'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L53 (error at <module>:32) else goto L12
L12:
    inc_ref r34
    inc_ref r35
    inc_ref r36
    inc_ref r40
    r44 = (r34, r35, r36, r39, r40, r43)
    r45 = box(tuple[object, object, object, object, object, object], r44)
    r46 = PyObject_GetItem(r33, r45)
    dec_ref r33
    dec_ref r45
    if is_error(r46) goto L51 (error at <module>:32) else goto L13
L13:
    r47 = faster_hexbytes.main.globals :: static
    r48 = 'BytesLike'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L51 (error at <module>:32) else goto L14 :: bool
L14:
    r51 = 'HexBytesOrSubclass'
    r52 = 'HexBytes'
    r53 = faster_hexbytes.main.globals :: static
    r54 = 'TypeVar'
    r55 = CPyDict_GetItem(r53, r54)
    if is_error(r55) goto L51 (error at <module>:34) else goto L15
L15:
    r56 = [r51, r52]
    r57 = load_address r56
    r58 = ('bound',)
    r59 = PyObject_Vectorcall(r55, r57, 1, r58)
    dec_ref r55
    if is_error(r59) goto L51 (error at <module>:34) else goto L16
L16:
    r60 = faster_hexbytes.main.globals :: static
    r61 = 'HexBytesOrSubclass'
    r62 = CPyDict_SetItem(r60, r61, r59)
    dec_ref r59
    r63 = r62 >= 0 :: signed
    if not r63 goto L51 (error at <module>:34) else goto L17 :: bool
L17:
    r64 = load_address PyBytes_Type
    r65 = '__new__'
    r66 = CPyObject_GetAttr(r64, r65)
    if is_error(r66) goto L51 (error at <module>:36) else goto L18
L18:
    faster_hexbytes.main._bytes_new = r66 :: static
    r67 = faster_hexbytes.main.globals :: static
    r68 = '_bytes_new'
    r69 = CPyDict_SetItem(r67, r68, r66)
    dec_ref r66
    r70 = r69 >= 0 :: signed
    if not r70 goto L51 (error at <module>:36) else goto L19 :: bool
L19:
    r71 = hexbytes.main :: module
    r72 = 'HexBytes'
    r73 = CPyObject_GetAttr(r71, r72)
    if is_error(r73) goto L51 (error at <module>:40) else goto L20
L20:
    r74 = PyTuple_Pack(1, r73)
    dec_ref r73
    if is_error(r74) goto L51 (error at <module>:40) else goto L21
L21:
    r75 = load_address PyType_Type
    r76 = CPy_CalculateMetaclass(r75, r74)
    if is_error(r76) goto L54 (error at <module>:40) else goto L22
L22:
    r77 = '__prepare__'
    r78 = PyObject_HasAttr(r76, r77)
    if r78 goto L23 else goto L27 :: bool
L23:
    r79 = 'HexBytes'
    r80 = '__prepare__'
    r81 = CPyObject_GetAttr(r76, r80)
    if is_error(r81) goto L54 (error at <module>:40) else goto L24
L24:
    r82 = [r79, r74]
    r83 = load_address r82
    r84 = PyObject_Vectorcall(r81, r83, 2, 0)
    dec_ref r81
    if is_error(r84) goto L54 (error at <module>:40) else goto L25
L25:
    r85 = cast(dict, r84)
    if is_error(r85) goto L54 (error at <module>:40) else goto L26
L26:
    r86 = r85
    goto L29
L27:
    r87 = PyDict_New()
    if is_error(r87) goto L54 (error at <module>:40) else goto L28
L28:
    r86 = r87
L29:
    r88 = PyDict_New()
    if is_error(r88) goto L55 (error at <module>:40) else goto L30
L30:
    r89 = __new___HexBytes_obj()
    if is_error(r89) goto L56 (error at <module>:51) else goto L31
L31:
    r90 = builtins :: module
    r91 = 'staticmethod'
    r92 = CPyObject_GetAttr(r90, r91)
    if is_error(r92) goto L57 (error at <module>:51) else goto L32
L32:
    r93 = [r89]
    r94 = load_address r93
    r95 = PyObject_Vectorcall(r92, r94, 1, 0)
    dec_ref r92
    if is_error(r95) goto L57 (error at <module>:51) else goto L33
L33:
    dec_ref r89
    r96 = '__new__'
    r97 = CPyDict_SetItem(r86, r96, r95)
    dec_ref r95
    r98 = r97 >= 0 :: signed
    if not r98 goto L56 (error at <module>:51) else goto L34 :: bool
L34:
    r99 = __getitem___HexBytes_obj()
    if is_error(r99) goto L56 (error at <module>:63) else goto L35
L35:
    r100 = '__getitem__'
    r101 = CPyDict_SetItem(r86, r100, r99)
    dec_ref r99
    r102 = r101 >= 0 :: signed
    if not r102 goto L56 (error at <module>:63) else goto L36 :: bool
L36:
    r103 = __repr___HexBytes_obj()
    if is_error(r103) goto L56 (error at <module>:75) else goto L37
L37:
    r104 = '__repr__'
    r105 = CPyDict_SetItem(r86, r104, r103)
    dec_ref r103
    r106 = r105 >= 0 :: signed
    if not r106 goto L56 (error at <module>:75) else goto L38 :: bool
L38:
    r107 = to_0x_hex_HexBytes_obj()
    if is_error(r107) goto L56 (error at <module>:78) else goto L39
L39:
    r108 = 'to_0x_hex'
    r109 = CPyDict_SetItem(r86, r108, r107)
    dec_ref r107
    r110 = r109 >= 0 :: signed
    if not r110 goto L56 (error at <module>:78) else goto L40 :: bool
L40:
    r111 = __reduce___HexBytes_obj()
    if is_error(r111) goto L56 (error at <module>:84) else goto L41
L41:
    r112 = '__reduce__'
    r113 = CPyDict_SetItem(r86, r112, r111)
    dec_ref r111
    r114 = r113 >= 0 :: signed
    if not r114 goto L56 (error at <module>:84) else goto L42 :: bool
L42:
    r115 = 'HexBytes'
    r116 = '__annotations__'
    r117 = CPyDict_SetItem(r86, r116, r88)
    dec_ref r88
    r118 = r117 >= 0 :: signed
    if not r118 goto L55 (error at <module>:40) else goto L43 :: bool
L43:
    r119 = 'mypyc filler docstring'
    r120 = '__doc__'
    r121 = CPyDict_SetItem(r86, r120, r119)
    r122 = r121 >= 0 :: signed
    if not r122 goto L55 (error at <module>:40) else goto L44 :: bool
L44:
    r123 = 'faster_hexbytes.main'
    r124 = '__module__'
    r125 = CPyDict_SetItem(r86, r124, r123)
    r126 = r125 >= 0 :: signed
    if not r126 goto L55 (error at <module>:40) else goto L45 :: bool
L45:
    r127 = [r115, r74, r86]
    r128 = load_address r127
    r129 = PyObject_Vectorcall(r76, r128, 3, 0)
    if is_error(r129) goto L55 (error at <module>:40) else goto L46
L46:
    dec_ref r86
    dec_ref r74
    r130 = faster_hexbytes.main.globals :: static
    r131 = 'mypyc_attr'
    r132 = CPyDict_GetItem(r130, r131)
    if is_error(r132) goto L58 (error at <module>:39) else goto L47
L47:
    r133 = box(bool, 0)
    r134 = [r133]
    r135 = load_address r134
    r136 = ('native_class',)
    r137 = PyObject_Vectorcall(r132, r135, 0, r136)
    dec_ref r132
    if is_error(r137) goto L58 (error at <module>:39) else goto L48
L48:
    r138 = [r129]
    r139 = load_address r138
    r140 = PyObject_Vectorcall(r137, r139, 1, 0)
    dec_ref r137
    if is_error(r140) goto L58 (error at <module>:40) else goto L49
L49:
    dec_ref r129
    faster_hexbytes.main.HexBytes = r140 :: type
    r141 = faster_hexbytes.main.globals :: static
    r142 = 'HexBytes'
    r143 = PyDict_SetItem(r141, r142, r140)
    dec_ref r140
    r144 = r143 >= 0 :: signed
    if not r144 goto L51 (error at <module>:40) else goto L50 :: bool
L50:
    r145 = faster_hexbytes.main.HexBytes :: type
    return 1
L51:
    r146 = <error> :: None
    return r146
L52:
    dec_ref r33
    goto L51
L53:
    dec_ref r33
    dec_ref r39
    goto L51
L54:
    dec_ref r74
    goto L51
L55:
    dec_ref r74
    dec_ref r86
    goto L51
L56:
    dec_ref r74
    dec_ref r86
    dec_ref r88
    goto L51
L57:
    dec_ref r74
    dec_ref r86
    dec_ref r88
    dec_ref r89
    goto L51
L58:
    dec_ref r129
    goto L51

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5, r6 :: object
    r7 :: str
    r8 :: dict
    r9, r10 :: object
    r11 :: str
    r12 :: dict
    r13 :: object
    r14 :: str
    r15 :: list
    r16, r17 :: ptr
    r18 :: dict
    r19 :: str
    r20 :: i32
    r21 :: bit
    r22 :: str
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L12 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('version',)
    r6 = ('__version',)
    r7 = 'importlib.metadata'
    r8 = faster_hexbytes.globals :: static
    r9 = CPyImport_ImportFromMany(r7, r5, r6, r8)
    if is_error(r9) goto L12 (error at <module>:1) else goto L4
L4:
    importlib.metadata = r9 :: module
    dec_ref r9
    r10 = ('HexBytes',)
    r11 = 'faster_hexbytes.main'
    r12 = faster_hexbytes.globals :: static
    r13 = CPyImport_ImportFromMany(r11, r10, r10, r12)
    if is_error(r13) goto L12 (error at <module>:5) else goto L5
L5:
    faster_hexbytes.main = r13 :: module
    dec_ref r13
    r14 = 'HexBytes'
    r15 = PyList_New(1)
    if is_error(r15) goto L12 (error at <module>:9) else goto L6
L6:
    r16 = get_element_ptr r15 ob_item :: PyListObject
    r17 = load_mem r16 :: ptr*
    inc_ref r14
    set_mem r17, r14 :: builtins.object*
    r18 = faster_hexbytes.globals :: static
    r19 = '__all__'
    r20 = CPyDict_SetItem(r18, r19, r15)
    dec_ref r15
    r21 = r20 >= 0 :: signed
    if not r21 goto L12 (error at <module>:9) else goto L7 :: bool
L7:
    r22 = 'hexbytes'
    r23 = faster_hexbytes.globals :: static
    r24 = '__version'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L12 (error at <module>:11) else goto L8
L8:
    r26 = [r22]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L12 (error at <module>:11) else goto L9
L9:
    r29 = cast(str, r28)
    if is_error(r29) goto L12 (error at <module>:11) else goto L10
L10:
    r30 = faster_hexbytes.globals :: static
    r31 = '__version__'
    r32 = CPyDict_SetItem(r30, r31, r29)
    dec_ref r29
    r33 = r32 >= 0 :: signed
    if not r33 goto L12 (error at <module>:11) else goto L11 :: bool
L11:
    return 1
L12:
    r34 = <error> :: None
    return r34

def to_bytes(val):
    val :: union[bytes, str, object, bool, int]
    r0 :: bit
    r1 :: bytes
    r2 :: bit
    r3 :: str
    r4 :: bytes
    r5 :: bit
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: bytes
    r11 :: bit
    r12 :: bool
    r13, r14, r15 :: bytes
    r16 :: bit
    r17 :: int
    r18 :: native_int
    r19 :: bit
    r20 :: native_int
    r21, r22 :: bit
    r23 :: bool
    r24 :: bit
    r25 :: str
    r26 :: int
    r27, r28, r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: int
    r37 :: object
    r38 :: str
    r39, r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: str
    r45 :: bytes
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: bool
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55 :: object
    r56 :: bytes
    r57, r58, r59, r60, r61 :: str
    r62 :: object[3]
    r63 :: object_ptr
    r64 :: object
    r65, r66 :: str
    r67 :: object
    r68, r69 :: str
    r70 :: object[3]
    r71 :: object_ptr
    r72 :: object
    r73 :: str
    r74 :: list
    r75, r76, r77, r78, r79, r80 :: ptr
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object
    r85 :: object[1]
    r86 :: object_ptr
    r87 :: object
    r88 :: bytes
L0:
    r0 = PyBytes_Check(val)
    if r0 goto L1 else goto L3 :: bool
L1:
    inc_ref val
    r1 = cast(bytes, val)
    if is_error(r1) goto L51 (error at to_bytes:19) else goto L2
L2:
    return r1
L3:
    r2 = PyUnicode_Check(val)
    if r2 goto L4 else goto L7 :: bool
L4:
    inc_ref val
    r3 = cast(str, val)
    if is_error(r3) goto L51 (error at to_bytes:21) else goto L5
L5:
    r4 = hexstr_to_bytes(r3)
    dec_ref r3
    if is_error(r4) goto L51 (error at to_bytes:21) else goto L6
L6:
    return r4
L7:
    r5 = PyByteArray_Check(val)
    if r5 goto L8 else goto L11 :: bool
L8:
    r6 = load_address PyBytes_Type
    r7 = [val]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r6, r8, 1, 0)
    if is_error(r9) goto L51 (error at to_bytes:23) else goto L9
L9:
    r10 = cast(bytes, r9)
    if is_error(r10) goto L51 (error at to_bytes:23) else goto L10
L10:
    return r10
L11:
    r11 = PyBool_Check(val)
    if r11 goto L12 else goto L17 :: bool
L12:
    r12 = unbox(bool, val)
    if is_error(r12) goto L51 (error at to_bytes:25) else goto L13
L13:
    if r12 goto L14 else goto L15 :: bool
L14:
    r13 = b'\x01'
    inc_ref r13
    r14 = r13
    goto L16
L15:
    r15 = b'\x00'
    inc_ref r15
    r14 = r15
L16:
    return r14
L17:
    r16 = PyLong_Check(val)
    if r16 goto L18 else goto L37 :: bool
L18:
    r17 = unbox(int, val)
    if is_error(r17) goto L51 (error at to_bytes:29) else goto L19
L19:
    r18 = r17 & 1
    r19 = r18 != 0
    if r19 goto L21 else goto L20 :: bool
L20:
    r20 = 0 & 1
    r21 = r20 != 0
    if r21 goto L21 else goto L22 :: bool
L21:
    r22 = CPyTagged_IsLt_(r17, 0)
    r23 = r22
    goto L23
L22:
    r24 = r17 < 0 :: signed
    r23 = r24
L23:
    dec_ref r17 :: int
    if r23 goto L24 else goto L31 :: bool
L24:
    r25 = 'Cannot convert negative integer '
    r26 = unbox(int, val)
    if is_error(r26) goto L51 (error at to_bytes:30) else goto L25
L25:
    r27 = CPyTagged_Str(r26)
    dec_ref r26 :: int
    if is_error(r27) goto L51 (error at to_bytes:30) else goto L26
L26:
    r28 = ' to bytes'
    r29 = CPyStr_Build(3, r25, r27, r28)
    dec_ref r27
    if is_error(r29) goto L51 (error at to_bytes:30) else goto L27
L27:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L52 (error at to_bytes:30) else goto L28
L28:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L52 (error at to_bytes:30) else goto L29
L29:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L51 (error at to_bytes:30) else goto L30 :: bool
L30:
    unreachable
L31:
    r36 = unbox(int, val)
    if is_error(r36) goto L51 (error at to_bytes:32) else goto L32
L32:
    r37 = builtins :: module
    r38 = 'hex'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L53 (error at to_bytes:32) else goto L33
L33:
    r40 = box(int, r36)
    r41 = [r40]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r39, r42, 1, 0)
    dec_ref r39
    if is_error(r43) goto L54 (error at to_bytes:32) else goto L34
L34:
    dec_ref r40
    r44 = cast(str, r43)
    if is_error(r44) goto L51 (error at to_bytes:32) else goto L35
L35:
    r45 = to_bytes(r44)
    dec_ref r44
    if is_error(r45) goto L51 (error at to_bytes:32) else goto L36
L36:
    return r45
L37:
    r46 = builtins :: module
    r47 = 'memoryview'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L51 (error at to_bytes:33) else goto L38
L38:
    r49 = PyObject_IsInstance(val, r48)
    dec_ref r48
    r50 = r49 >= 0 :: signed
    if not r50 goto L51 (error at to_bytes:33) else goto L39 :: bool
L39:
    r51 = truncate r49: i32 to builtins.bool
    if r51 goto L40 else goto L43 :: bool
L40:
    r52 = load_address PyBytes_Type
    r53 = [val]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 1, 0)
    if is_error(r55) goto L51 (error at to_bytes:34) else goto L41
L41:
    r56 = cast(bytes, r55)
    if is_error(r56) goto L51 (error at to_bytes:34) else goto L42
L42:
    return r56
L43:
    r57 = ''
    r58 = 'Cannot convert '
    r59 = '{!r:{}}'
    r60 = ''
    r61 = 'format'
    r62 = [r59, val, r60]
    r63 = load_address r62
    r64 = PyObject_VectorcallMethod(r61, r63, 9223372036854775811, 0)
    if is_error(r64) goto L51 (error at to_bytes:36) else goto L44
L44:
    r65 = ' of type '
    r66 = '{:{}}'
    r67 = CPy_TYPE(val)
    r68 = ''
    r69 = 'format'
    r70 = [r66, r67, r68]
    r71 = load_address r70
    r72 = PyObject_VectorcallMethod(r69, r71, 9223372036854775811, 0)
    if is_error(r72) goto L55 (error at to_bytes:36) else goto L45
L45:
    dec_ref r67
    r73 = ' to bytes'
    r74 = PyList_New(5)
    if is_error(r74) goto L56 (error at to_bytes:36) else goto L46
L46:
    r75 = get_element_ptr r74 ob_item :: PyListObject
    r76 = load_mem r75 :: ptr*
    inc_ref r58
    set_mem r76, r58 :: builtins.object*
    r77 = r76 + 8
    set_mem r77, r64 :: builtins.object*
    inc_ref r65
    r78 = r76 + 16
    set_mem r78, r65 :: builtins.object*
    r79 = r76 + 24
    set_mem r79, r72 :: builtins.object*
    inc_ref r73
    r80 = r76 + 32
    set_mem r80, r73 :: builtins.object*
    r81 = PyUnicode_Join(r57, r74)
    dec_ref r74
    if is_error(r81) goto L51 (error at to_bytes:36) else goto L47
L47:
    r82 = builtins :: module
    r83 = 'TypeError'
    r84 = CPyObject_GetAttr(r82, r83)
    if is_error(r84) goto L57 (error at to_bytes:36) else goto L48
L48:
    r85 = [r81]
    r86 = load_address r85
    r87 = PyObject_Vectorcall(r84, r86, 1, 0)
    dec_ref r84
    if is_error(r87) goto L57 (error at to_bytes:36) else goto L49
L49:
    dec_ref r81
    CPy_Raise(r87)
    dec_ref r87
    if not 0 goto L51 (error at to_bytes:36) else goto L50 :: bool
L50:
    unreachable
L51:
    r88 = <error> :: bytes
    return r88
L52:
    dec_ref r29
    goto L51
L53:
    dec_ref r36 :: int
    goto L51
L54:
    dec_ref r40
    goto L51
L55:
    dec_ref r64
    dec_ref r67
    goto L51
L56:
    dec_ref r64
    dec_ref r72
    goto L51
L57:
    dec_ref r81
    goto L51

def hexstr_to_bytes(hexstr):
    hexstr, r0, r1 :: str
    r2 :: tuple[str, str]
    r3 :: object
    r4 :: bool
    r5 :: object
    r6, non_prefixed_hex :: str
    r7 :: native_int
    r8 :: bit
    r9 :: short_int
    r10 :: int
    r11 :: bit
    r12, r13, padded_hex :: str
    r14 :: bytes
    r15 :: tuple[object, object, object]
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20, r21, r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35, r36 :: bytes
L0:
    r0 = '0x'
    r1 = '0X'
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[str, str], r2)
    r4 = CPyStr_Startswith(hexstr, r3)
    dec_ref r3
    if is_error(r4) goto L31 (error at hexstr_to_bytes:40) else goto L1
L1:
    if r4 goto L2 else goto L5 :: bool
L2:
    r5 = CPyStr_GetSlice(hexstr, 4, 9223372036854775806)
    if is_error(r5) goto L31 (error at hexstr_to_bytes:41) else goto L3
L3:
    r6 = cast(str, r5)
    if is_error(r6) goto L31 (error at hexstr_to_bytes:41) else goto L4
L4:
    non_prefixed_hex = r6
    goto L6
L5:
    inc_ref hexstr
    non_prefixed_hex = hexstr
L6:
    r7 = CPyStr_Size_size_t(hexstr)
    r8 = r7 >= 0 :: signed
    if not r8 goto L32 (error at hexstr_to_bytes:46) else goto L7 :: bool
L7:
    r9 = r7 << 1
    r10 = CPyTagged_Remainder(r9, 4)
    if is_error(r10) goto L32 (error at hexstr_to_bytes:46) else goto L8
L8:
    r11 = r10 != 0
    dec_ref r10 :: int
    if r11 goto L9 else goto L11 :: bool
L9:
    r12 = '0'
    r13 = PyUnicode_Concat(r12, non_prefixed_hex)
    dec_ref non_prefixed_hex
    if is_error(r13) goto L31 (error at hexstr_to_bytes:47) else goto L10
L10:
    padded_hex = r13
    goto L12
L11:
    padded_hex = non_prefixed_hex
L12:
    r14 = PyUnicode_AsASCIIString(padded_hex)
    if is_error(r14) goto L14 (error at hexstr_to_bytes:52) else goto L33
L13:
    goto L25
L14:
    r15 = CPy_CatchError()
    r16 = builtins :: module
    r17 = 'UnicodeDecodeError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L34 (error at hexstr_to_bytes:53) else goto L15
L15:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L16 else goto L35 :: bool
L16:
    r20 = 'hex string '
    r21 = ' may only contain [0-9a-fA-F] characters'
    r22 = CPyStr_Build(3, r20, padded_hex, r21)
    dec_ref padded_hex
    if is_error(r22) goto L23 (error at hexstr_to_bytes:55) else goto L17
L17:
    r23 = builtins :: module
    r24 = 'ValueError'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L36 (error at hexstr_to_bytes:54) else goto L18
L18:
    r26 = [r22]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L36 (error at hexstr_to_bytes:54) else goto L19
L19:
    dec_ref r22
    CPy_Raise(r28)
    dec_ref r28
    if not 0 goto L23 (error at hexstr_to_bytes:54) else goto L37 :: bool
L20:
    unreachable
L21:
    CPy_Reraise()
    if not 0 goto L23 else goto L38 :: bool
L22:
    unreachable
L23:
    CPy_RestoreExcInfo(r15)
    dec_ref r15
    r29 = CPy_KeepPropagating()
    if not r29 goto L31 else goto L24 :: bool
L24:
    unreachable
L25:
    r30 = faster_hexbytes._utils.unhexlify :: static
    if is_error(r30) goto L39 else goto L28
L26:
    r31 = raise NameError('value for final name "unhexlify" was not set')
    if not r31 goto L31 (error at hexstr_to_bytes:58) else goto L27 :: bool
L27:
    unreachable
L28:
    r32 = [r14]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r30, r33, 1, 0)
    if is_error(r34) goto L40 (error at hexstr_to_bytes:58) else goto L29
L29:
    dec_ref r14
    r35 = cast(bytes, r34)
    if is_error(r35) goto L31 (error at hexstr_to_bytes:58) else goto L30
L30:
    return r35
L31:
    r36 = <error> :: bytes
    return r36
L32:
    dec_ref non_prefixed_hex
    goto L31
L33:
    dec_ref padded_hex
    goto L13
L34:
    dec_ref padded_hex
    goto L23
L35:
    dec_ref padded_hex
    goto L21
L36:
    dec_ref r22
    goto L23
L37:
    dec_ref r15
    goto L20
L38:
    dec_ref r15
    goto L22
L39:
    dec_ref r14
    goto L26
L40:
    dec_ref r14
    goto L31

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: i32
    r25 :: bit
    r26 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address binascii :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('binascii', 'binascii', 'binascii'),)
    r11 = faster_hexbytes._utils.globals :: static
    r12 = 'faster_hexbytes/_utils.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L8 else goto L4 :: bool
L4:
    r15 = ('Final', 'Union')
    r16 = 'typing'
    r17 = faster_hexbytes._utils.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L8 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = binascii :: module
    r20 = 'unhexlify'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L8 (error at <module>:8) else goto L6
L6:
    faster_hexbytes._utils.unhexlify = r21 :: static
    r22 = faster_hexbytes._utils.globals :: static
    r23 = 'unhexlify'
    r24 = CPyDict_SetItem(r22, r23, r21)
    dec_ref r21
    r25 = r24 >= 0 :: signed
    if not r25 goto L8 (error at <module>:8) else goto L7 :: bool
L7:
    return 1
L8:
    r26 = <error> :: None
    return r26
